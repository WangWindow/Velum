# 4 项目实现方案（后端优先）

## 4.1 总览

本章详细描述后端实现方案，逐模块说明设计与实现要点，覆盖认证/授权、数据层、测评逻辑、聊天与 AI 集成、统计与分析、配置与安全等。文档基于仓库代码（`backend` 目录）摘录并补充实现细节。

## 4.2 后端总体架构回顾

- 入口：`backend/api/Program.cs` 配置 DI、EF Core、JWT、OpenAPI
- 控制器（Controllers）：`backend/api/Controllers/*Controller.cs`（`AuthController`、`ChatController`、`AssessmentsController`、`DashboardController` 等）负责 HTTP 层
- 业务层（Services）：`backend/base/Services/*Service.cs`（`AuthService`、`ChatService`、`AssessmentService`、`AnalysisService`、`DashboardService` 等）实现核心逻辑
- 数据层（Domain Models / DbContext）：`backend/core/Models` 与 `backend/base/Data/ApplicationDbContext.cs`
- 配置与运维：`appsettings.json` / `appsettings.local.json` / 环境变量；`DatabaseConfigurationSource` 支持从 DB 中加载部分配置（如 AppSettings 表内容）

## 4.3 认证与密码处理

### 4.3.1 JWT 认证

- 在 `Program.cs` 中通过 `AddAuthentication(JwtBearerDefaults.AuthenticationScheme)` 配置 JWT，使用 `Jwt:Key`、`Jwt:Issuer`、`Jwt:Audience`。
- `AuthService.GenerateJwtToken(User)` 使用 HMAC SHA256 签名生成 token，包含 `sub`, `role`, `UserId` 等声明，过期时间 120 分钟。
- 控制器使用 `[Authorize]` 与 `[Authorize(Roles = "admin")]` 标记进行接口访问控制。

### 4.3.2 RSA 密码加密（可选）

- `PasswordManager` 实现 RSA 密钥管理：当 `Rsa:Enabled=true` 且未配置密钥时，会自动生成一对 2048 位密钥并尝试写入 `appsettings.local.json`，同时在终端打印密钥，便于开发者复制。
- 前端可通过 `GET /api/auth/publickey` 获取公钥并在客户端使用 `jsencrypt` 加密密码后再提交。
- 后端 `PasswordManager.ProcessPassword()` 会对收到的 Base64 RSA 密文进行解密并返回明文用于校验或存储。

安全注意：当前用户密码在数据库中以明文保存（代码中 `User.Password` 即明文）。这是项目实现的简化，可在后续改造为哈希存储（推荐：PBKDF2/BCrypt/Argon2），并保留 RSA 传输保护来防止明文在网络层泄露。

## 4.4 数据模型与持久化

核心实体（摘自 `core/Models` 与 `ApplicationDbContext`）：

- `User`：Id, Username, Password, Email, FullName, Avatar, Role, CreatedAt, LastLogin
- `Questionnaire`：Id, Title, Description, InterpretationGuide, QuestionsJson, Language, GroupId, IsActive, CreatedAt
- `Assessment`：Id, UserId, QuestionnaireId, UserTaskId, Date, Score, Result, DetailsJson, AnalysisJson
- `ChatSession` / `ChatMessage`：支持会话与消息的多条保存，`ChatSession` 与 `ChatMessage` 采用一对多关系（Cascade Delete）
- `AppSetting` / `SystemLog` / `UserTask` 等用于配置、审计与任务流程

数据库采用 EF Core + SQLite（默认），`Program.cs` 在启动时执行 `db.Database.Migrate()` 并调用 `SeedData.InitializeAsync(db)` 填充初始用户。

ER 图请参考 docs/3.md 已给出 PlantUML 描述。

## 4.5 关键服务实现详解

### 4.5.1 `AuthService`（`backend/base/Services/AuthService.cs`）

- 功能：登录、注册、JWT 生成
- 登录流程：查询用户 -> 使用 `PasswordManager.VerifyPassword`（可解密）对比 -> 生成 JWT 返回
- 注册流程：检查用户名唯一性 -> 校验 `AdminSettings:RegistrationKey` -> 使用 `PasswordManager.ProcessPassword` 解密输入 -> 保存用户（明文密码）
- 建议优化点：密码存储改为不可逆哈希、登录失败次数限制、IP/设备审计、强密码策略

### 4.5.2 `AssessmentService`（`backend/base/Services/AssessmentService.cs`）

- 功能：获取用户测评、提交测评并计算分数
- 实现要点：
  - `SubmitAssessmentAsync` 接受 `answers`（字典），遍历值进行数值累加来计算总分；将原始答案序列化到 `DetailsJson`，保存 `Score`、`Result`（示例阈值规则）
  - 若存在对应 `UserTask`（待办任务），则标记为已完成并关联 `UserTaskId`
- 说明：当前的计分规则为示例（简单累加且使用固定阈值），实际生产应通过问卷定义明确分值映射与解释区间（Questionnaire 的 `InterpretationGuide` 可用于传入 AI 分析或更复杂映射）

### 4.5.3 `ChatService`（`backend/base/Services/ChatService.cs`）

- 功能：会话管理、消息存储、请求 AI 生成回复、支持流式返回
- 实现要点：
  - `ProcessUserMessageAsync`：保存用户消息 -> 调用 `IOpenAIService.GetChatCompletionAsync(message)` -> 保存 AI 回复作为 `ChatMessage` 返回
  - `ProcessUserMessageStreamingAsync`：保存用户消息 -> 逐块从 `IOpenAIService.GetChatStreamingAsync(message)` 读取流片段并逐次 yield（供控制器 `SendMessageStream` 将 chunk 写回 Response），最终将完整回复保存为单条 `ChatMessage`
  - 会话标题自动生成（基于首条消息）并更新 `UpdatedAt`
- 改进建议：将历史会话拼接为 prompt 传给 AI，以获得上下文相关的回复；对流式 chunk 做增量持久化/补偿策略以避免丢失

### 4.5.4 `OpenAIService`（`backend/base/Services/OpenAIService.cs`）

- 功能：与外部 AI 模型交互，支持普通完成与流式完成，和特定任务（问卷解析、双语解析）
- 实现要点：
  - 初始化时尝试从数据库 `AppSettings` 读取 `AiApiKey`、`AiApiUrl`（优先级：DB -> config）
  - `GetChatCompletionAsync(prompt)` 使用 SDK 同步完成
  - `GetChatStreamingAsync(prompt)` 基于 SDK 的流式接口，将 `StreamingChatCompletionUpdate` 的片段暴露为 `IAsyncEnumerable<string>`
  - `ParseQuestionnaireFromTextAsync` / `ParseAndTranslateQuestionnaireAsync` 包装了专门的 system prompt，供管理员上传量表文本并自动解析结构化问卷
- 注意：需要在生产中把 API Key 以及模型地址从安全存储（环境变量/密钥管理服务）注入到 `AppSettings` 或环境变量中

### 4.5.5 `AnalysisService` 与 `DashboardService`

- `AnalysisService` 提供基于 AI 的测评解释（`AnalyzeAssessmentAsync`）和整体统计（`GetOverallStatsAsync`、`GetUserAnalysisAsync`、`GetAssessmentExportDataAsync`）
- `DashboardService` 提供管理端仪表盘数据（`GetStatsAsync`、`GetChartDataAsync`）用于图表展示

## 4.6 API 设计（主要端点、示例）

以下按 Controller 分类，给出主要 API 路径与示例请求/响应（基于代码）：

### 4.6.1 Auth

- GET /api/auth/publickey
  - 说明：返回 RSA 公钥（当 `Rsa:Enabled=true` 且配置存在）
  - 响应示例：{ "publicKey": "BASE64..." }

- POST /api/auth/login
  - 请求体：{ "username": "user", "password": "..." }
  - 成功响应：{
      "token": "ey...",
      "role": "user",
      "user": { "id":1, "username":"user", "fullName":"Demo User", "email":"user@velum.com" }
    }

- POST /api/auth/register
  - 请求体：{ "username": "u", "password": "p", "email":"e", "fullName":"f", "registrationKey":"114514" }
  - 成功响应：{ "message": "User registered successfully" }

### 4.6.2 Assessments

- GET /api/assessments/my
  - 说明：获取当前用户的测评历史（需 JWT）

- POST /api/assessments
  - 请求体：{ "questionnaireId": 1, "answers": { "1": 2, "2": 3, ... } }
  - 成功响应示例：Assessment 对象（包含 `Score`, `Result`, `DetailsJson`）

### 4.6.3 Chat

- GET /api/chat/sessions
- POST /api/chat/sessions
- GET /api/chat/sessions/{id}
- DELETE /api/chat/sessions/{id}
- POST /api/chat/send
  - 请求体：{ "message": "Hello", "sessionId": 1 }
  - 响应：AI 的单条 `ChatMessage`
- POST /api/chat/stream
  - 请求体：{ "message":"...", "sessionId":1 }
  - 响应：text/plain 流式 chunk（Controller `SendMessageStream` 将逐 chunk 写回）

### 4.6.4 Dashboard / Analysis / Settings

- GET /api/dashboard/stats
- GET /api/dashboard/chart-data
- API 文档（Swagger）在非生产环境可用：`/swagger`

## 4.7 日志与审计

- `LogService` 将关键操作（登录失败、注册、创建会话、删除会话、清空历史等）写入 `SystemLog` 表
- 管理员可通过 `/api/logs`（控制器实现）检索审计记录用于排障与合规审查

## 4.8 错误处理与异常策略

- Controller 层目前以直接返回 HTTP 状态码为主（如 `Unauthorized`、`NotFound`、`BadRequest`），服务层抛出异常时，未统一映射到自定义错误格式
- 建议：引入全局异常处理中间件，统一日志记录、返回标准错误响应（包含 ErrorCode、Message、TraceId）以便前端展示与排查

## 4.9 配置与部署注意事项（后端重点）

- `appsettings.json` 提供默认值，敏感配置（`Jwt:Key`, `OpenAI:ApiKey`, `Rsa:PrivateKey`）应通过环境变量注入
- `DatabaseConfigurationProvider` 支持把 AppSetting 从 DB 加载，便于运行时调整 AI Key 或其他配置但要注意启动迁移顺序
- 数据库在生产建议迁移到更可靠的 RDBMS（Postgres/SQL Server）并使用持久化存储

## 4.10 小结（后端亮点与改进点）

- 亮点：
  - AI 集成设计清晰（完成/流式/问卷解析/双语解析）；
  - 可选 RSA 加密前端密码保护；
  - 配置支持 DB 存储并覆盖 appsettings；
  - 以 `Service` 接口抽象便于替换实现。

- 改进点：
  - 密码存储需使用强哈希；
  - AI prompt 需要包含上下文历史；
  - 更细粒度的错误/审计日志；
  - 流式回复需要对客户端断连/续传做容错处理。

## 4.11 图片与截图占位

- 【截图占位：Swagger 页面展示（/swagger）】
- 【截图占位：数据库迁移/启动日志（包含 RSA keys 打印的示例）】
- 【截图占位：数据库表结构（SQLite 浏览器截图）】


---

下一步：我将基于上述后端实现，编写第5部分“实例验证与分析”，包含具体的请求/响应样例（curl/axios）、流程时序、验证注意点与截图/日志占位。
