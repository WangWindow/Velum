# 5 项目实例验证与分析

本章基于代码实现对若干核心功能链路做逐步验证说明，包括示例请求/响应、流程时序、数据持久化检查与结果分析。示例以后端当前实现为准（见 `backend/base/Services`），并给出前端调用示例（axios / curl）。

## 5.1 环境准备与启动（开发时）

已知：后端在 `backend/api`，前端在 `frontend`。

后端（.NET）开发启动示例：

```bash
# 在仓库根或 backend/api 目录
dotnet build
dotnet run --project backend/api/Velum.Api.csproj
```

前端开发启动示例（在 frontend 目录）：

```bash
npm install
npm run dev
# 默认端口见 vite.config.ts -> 14514
```

注意：若启用 RSA 自动生成密钥，`PasswordManager` 会在启动时将密钥打印并尝试写入 `appsettings.local.json`。

## 5.2 验证用例 1：用户登录（含 RSA 可选）

目的：验证登录流程、RSA 公钥获取、JWT 返回与日志写入

### 5.2.1 流程

1. 前端请求 `GET /api/auth/publickey` 获取公钥（若启用 RSA）
2. 前端用公钥加密密码并请求 `POST /api/auth/login`，或直接以明文密码请求（若未启用 RSA）
3. 后端 `AuthService.LoginAsync` 校验密码并返回 JWT
4. 前端保存 token（LocalStorage）并在后续请求添加 `Authorization: Bearer <token>`

### 5.2.2 示例（curl）

获取公钥（可选）：

```bash
curl http://localhost:17597/api/auth/publickey
# 响应: { "publicKey": "BASE64..." } 或 404
```

登录请求（不使用 RSA）：

```bash
curl -X POST http://localhost:17597/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"user123"}'
```

成功响应示例：

```json
{
  "token": "eyJhb...",
  "role": "user",
  "user": { "id": 2, "username": "user", "fullName": "Demo User", "email": "user@velum.com" }
}
```

### 5.2.3 验证点

- 检查返回的 `token` 可被 JWT 解码，包含 `UserId` 和 `role` 声明
- 后端 `SystemLog` 是否记录登录成功/失败（由 `ILogService` 触发日志写入）
- 若启用 RSA，验证 `PasswordManager` 能够成功解密前端加密后的密码

截图占位：
- 【截图占位：登录页面（/login）与控制台 Swagger 登录示例】

### 5.2.4 界面操作验证（Web/Tauri）

本用例建议以“真实界面操作 + 网络请求 + 成功跳转”三位一体的方式展示。

操作步骤（前端路由：`/login`）：

1. 打开登录页 `/login`，确认页面右上角存在：语言切换与主题切换（`LanguageToggle`、`ThemeToggle`）。
2. 在表单中输入：用户名、密码。
3. 点击“登录/提交”按钮：
   - 预期：成功后按角色自动跳转。
     - 普通用户：跳转到 `/user/dashboard`
     - 管理员：跳转到 `/admin/dashboard`
   - 失败预期：弹出 toast（失败提示）。
4. 若需要验证注册：点击“Sign Up/注册”切换到注册模式，补充填写邮箱、姓名、注册码（registrationKey），再点击注册。

建议截图点位：
- 【截图占位：登录页表单（展示语言/主题切换、用户名密码输入框）】
- 【截图占位：注册模式表单（展示注册码输入框）】
- 【截图占位：登录成功后的跳转页面（/user/dashboard 或 /admin/dashboard）】
- 【截图占位：浏览器开发者工具 Network：/api/auth/publickey 与 /api/auth/login 请求】


## 5.3 验证用例 2：问卷提交与得分计算

目的：验证 `POST /api/assessments` 的受权、计分逻辑、数据持久化与任务完成联动

### 5.3.1 流程

1. 登录并获得 token
2. 用户在前端读取问卷（`GET /api/questionnaire/{id}` 或从前端静态加载）
3. 提交测评答案到 `POST /api/assessments`，body 如 `{ "questionnaireId":1, "answers": {"1":2,"2":3} }`
4. 后端 `AssessmentService.SubmitAssessmentAsync` 计算分数、写入 `Assessments` 表并关联 `UserTask`（若存在等待任务）

### 5.3.2 示例（curl）

```bash
curl -X POST http://localhost:17597/api/assessments \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <TOKEN>" \
  -d '{"questionnaireId":1, "answers": {"1": 2, "2": 3}}'
```

返回示例（Assessment 对象）：

```json
{
  "id": 10,
  "userId": 2,
  "questionnaireId": 1,
  "date": "2025-12-30T08:00:00Z",
  "score": 5,
  "result": "Normal",
  "detailsJson": "{\"1\":2,\"2\":3}"
}
```

### 5.3.3 验证点

- DB 中 `Assessments` 表插入记录，`DetailsJson` 保存原始答案
- `Score` 计算是否与前端预期一致（注意：当前实现以数值累加为准）
- 若存在 `UserTask` 且未完成，则该任务状态更新为 `Completed`

截图占位：
- 【截图占位：前端测评页面（/user/assessment）】
- 【截图占位：SQLite 浏览器中 Assessment 表的一行记录】

### 5.3.4 界面操作验证（用户端测评页面）

该用例可直接在用户端界面完成，展示“列表页 -> 答题页 -> 提交成功 toast -> 数据落库”。

操作步骤（前端路由：`/user/assessment`）：

1. 登录为普通用户后进入 `/user/assessment`。
2. 在“测评列表页”中，选择任意量表卡片（卡片包含题目数量），点击“Start/开始测评”按钮。
3. 进入答题页后：
  - 页面顶部显示当前量表标题与说明；
  - 页面上方存在进度条（Progress）与百分比。
4. 逐题作答：
  - 单选题：RadioGroup
  - 多选题：Checkbox（可多选/取消）
  - 文本题：Textarea
5. 观察“提交”按钮：
  - 预期：未答完时按钮处于禁用状态；答完后变为可提交。
6. 点击提交：
  - 预期：弹出“submitted” toast；页面退出答题态并回到列表。

建议截图点位：
- 【截图占位：测评列表页（多个量表卡片 + Start 按钮）】
- 【截图占位：答题页（进度条 + 单选/多选/文本题示例各一张）】
- 【截图占位：提交按钮禁用->启用的对比（可用两张图）】
- 【截图占位：提交成功 toast】
- 【截图占位：Network：POST /api/assessments 请求与响应】


## 5.4 验证用例 3：AI 对话（普通与流式）

目的：验证 `ChatService` 与 `OpenAIService` 的联动，普通完成与流式返回的差别

### 5.4.1 普通完成（非流）

- 请求：`POST /api/chat/send`，body `{ "message":"我最近压力很大", "sessionId": 1 }`
- 后端行为：保存用户消息 -> 调用 `_openAIService.GetChatCompletionAsync(message)` -> 保存 AI 回复 -> 返回 AI `ChatMessage`

示例 curl：

```bash
curl -X POST http://localhost:17597/api/chat/send \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"message":"我最近压力很大","sessionId":1}'
```

响应为 AI 消息 JSON：{ "id":..., "content":"...", "role":"assistant", ... }

### 5.4.2 流式（Streaming）

- 请求：`POST /api/chat/stream`，同样的 body
- 响应：`text/plain`，Controller 将逐块写回 AI 流输出（`ProcessUserMessageStreamingAsync` yield 的每个 chunk）

curl 示例（简单流式读取）：

```bash
curl -N -X POST http://localhost:17597/api/chat/stream \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"message":"帮我分析一下最近的情绪","sessionId":1}'
```

`-N` 保持连接以接收流片段。前端应对返回的 text/plain 以流方式追加至显示区域。

### 5.4.3 验证点

- 流式过程中浏览器/客户端是否能实时显示接收到的文本片段
- 最终数据库中是否以完整文本保存 AI 回复（作为一条 `ChatMessage`）
- 当网络中断或客户端超时，服务端应完成写入或提供断点重试策略（当前实现无断点续传，需要增强）

截图占位：
- 【截图占位：AI 对话流式显示的 UI 截图】
- 【截图占位：后端控制台输出（流式 chunk 打印）】

### 5.4.4 界面操作验证（用户端 AI 对话页面，重点展示流式）

说明：当前前端默认使用后端流式接口（`/api/chat/stream`），在 UI 上表现为“AI 气泡内容逐字增长”。

操作步骤（前端路由：`/user/chat`）：

1. 进入 `/user/chat` 后，左侧应显示会话列表（Recent），并有“New Chat/新建对话”按钮。
2. 点击“New Chat”：
  - 预期：创建新会话并选中，会话标题默认为 New Chat。
3. 在底部输入框（Textarea）输入一段文本（如“我最近压力很大”），点击发送按钮（纸飞机图标）或回车发送。
4. 观察消息区：
  - 用户消息立即出现（保证响应速度）；
  - AI 消息气泡随后出现，内容逐步追加（流式展示）；
  - AI 消息支持 Markdown 渲染（富文本/换行/链接等）。
5. 会话管理（可选验证）：
  - 点击会话右侧的删除按钮（垃圾桶）弹出确认对话框；确认后会话消失；
  - 通过右侧设置按钮（齿轮）打开配置面板，可切换 default/custom 模式。

建议截图点位：
- 【截图占位：Chat 页面整体（左侧会话列表 + 右侧消息区 + 输入区）】
- 【截图占位：新建会话后，列表出现新会话条目】
- 【截图占位：发送后 AI 消息“逐步增长”的连续两张截图（体现流式）】
- 【截图占位：设置面板（custom 模式的 API URL/API Key/Model/SystemPrompt 输入项）】
- 【截图占位：Network：POST /api/chat/stream（Response 为 text/plain 流）】


## 5.5 验证用例 4：管理员仪表盘统计

目的：验证 `/api/dashboard/stats` 与 `/api/dashboard/chart-data` 是否返回可视化所需的结构化数据

示例 curl：

```bash
curl -H "Authorization: Bearer <ADMIN_TOKEN>" http://localhost:17597/api/dashboard/stats
```

返回示例摘录：

```json
{
  "totalUsers": 10,
  "activeTasks": 2,
  "revenue": 0,
  "systemStatus": "Healthy",
  "activities": [ ... ],
  "recentAssessments": [ ... ]
}
```

`chart-data` 返回时间序列 `Trend`（近7天）与 `Distribution`（任务状态分布），直接用于前端 ECharts 渲染。

验证点：
- 时间序列中缺失日期是否被填充为 0（`DashboardService` 已实现填充逻辑）
- `RecentAssessments` 包含问卷标题与用户信息

截图占位：
- 【截图占位：管理端仪表盘全图（含趋势图/分布图）】

### 5.5.4 界面操作验证（管理端仪表盘页面）

操作步骤（前端路由：`/admin/dashboard`）：

1. 使用管理员账号登录后，自动跳转到 `/admin/dashboard`。
2. 页面顶部显示标题与快捷按钮（进入用户管理、进入分析页）。
3. 观察四个统计卡片：
  - Total Users
  - Active Tasks
  - Completed Assessments
  - System Health
4. 观察图表区域（Overview）：
  - 预期：页面加载时出现 loading 动画；加载完成后显示趋势图。
5. 观察 Recent Activity/Recent Assessments 列表：
  - 预期：每条记录包含用户名、量表标题、分数、日期；点击“View All”进入分析模块。

建议截图点位：
- 【截图占位：仪表盘顶部区域（标题 + 两个快捷按钮）】
- 【截图占位：四个统计卡片】
- 【截图占位：趋势图（OverviewChart）】
- 【截图占位：RecentAssessments 列表（含用户名/量表/分数/日期）】
- 【截图占位：Network：GET /api/dashboard/stats 与 /api/dashboard/chart-data】


## 5.6 导出与分析功能验证

- `AnalysisService.GetAssessmentExportDataAsync(questionnaireId)` 会解析 `Questionnaire.QuestionsJson` 并为每个测评生成行数据（包含用户、时间、分数、每题答案）以便导出为 CSV/Excel
- 验证时需确保 `Questionnaire.QuestionsJson` 遵从前端上传/解析的 schema（`Question` 包含 `id` 与 `text`）

示例：
- 生成结果包含 Columns 列表和 Rows 数据，前端可将其转换为 CSV 并提供下载

截图占位：
- 【截图占位：导出结果 CSV 打开截图】


## 5.7 常见问题与排查

- 500 错误：查看后端控制台与 `SystemLog` 表以定位异常堆栈
- AI 请求失败：确认 `OpenAI:ApiKey`、`OpenAI:BaseUrl` 与模型配置是否正确；检查 `OpenAIService` 在启动时是否成功读取配置（DB 覆盖逻辑可能失败）
- RSA 密钥未生效：确认 `Rsa:Enabled=true` 且 `appsettings.local.json` 或环境变量中存在 `Rsa:PrivateKey` / `Rsa:PublicKey`

## 5.8 小结

- 后端实现已经覆盖典型业务链路：认证、测评、聊天（含流式）、统计与 AI 分析
- 当前实现对生产环境仍需若干改进（密码哈希、错误中间件、AI prompt 与上下文管理、流式容错）


---

接下来我将开始编写第6部分：部署流程（后端 Docker/云部署、前端 Web（Vercel）与 Tauri 打包）与实训总结；之后会把前端实现细节（路由/组件/状态管理/图表）补写进文档并与后端接口映射对齐。需要我现在继续写 `docs/6.md`（部署与总结）并随即转向前端实现细节吗？
